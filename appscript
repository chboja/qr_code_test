const SHEET_ID = "1p1tktgK4vo9Yyc_dC1NB5WL-m2HNS_R6vYZAWWJSMXQ";

function jsonpResponse(callback, payload) {
  return ContentService
    .createTextOutput(`${callback}(${JSON.stringify(payload)})`)
    .setMimeType(ContentService.MimeType.JAVASCRIPT);
}

function doGet(e) {
  const mode = e.parameter.mode;
  const callback = e.parameter.callback || "handlePostResponse";

  switch (mode) {
    case "breakfastSubmit":
      return handleBreakfastSubmit(e, callback);
    case "verifyReservation":
      return handleVerifyReservation(e, callback);
    case "searchName":
      return handleSearchByName(e, callback);
    case "searchRoom":
      return handleSearchByRoom(e, callback);
    case "importCsv":
      return handleImportCsv(e, callback);
    default:
      return handleDefault(e, callback);
  }
}

function handleBreakfastSubmit(e, callback) {
  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("breakfast_list");
    if (!sheet) throw new Error("breakfast_list not found");
    Logger.log("🟡 조식 데이터 기록 시도:", e.parameter);
    sheet.appendRow([e.parameter.timestamp, e.parameter.room, e.parameter.guests]);
    Logger.log("🟢 appendRow 완료");
    return jsonpResponse(callback, { success: true });
  } catch (err) {
    Logger.log("❌ 조식 기록 에러:", err);
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleVerifyReservation(e, callback) {
  try {
    const reservationToVerify = e.parameter.verifyReservation.trim().toLowerCase();
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");
    const data = sheet.getDataRange().getValues();
    const match = data.find((row, index) =>
      index !== 0 && String(row[0]).trim().toLowerCase() === reservationToVerify
    );
    const breakfastFlag = match ? String(match[6]) : null;
    return jsonpResponse(callback, {
      success: true,
      exists: !!match,
      breakfastFlag
    });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleSearchByName(e, callback) {
  try {
    const searchKey = e.parameter.name.toLowerCase().replace(/\s+/g, '');
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");
    const data = sheet.getDataRange().getValues();
    const matches = data.filter((row, index) => {
      if (index === 0) return false;
      const rowKey = (row[7] || "").toLowerCase().replace(/\s+/g, '');
      return rowKey.includes(searchKey);
    }).map(row => ({
      reservation: row[0],
      room: row[1],
      name: row[2],
      checkIn: row[3],
      checkOut: row[4],
      guestCount: row[5],
      breakfastFlag: row[6],
      unpaid: row[9],
      memo: row[10]
    }));
    return jsonpResponse(callback, { success: true, matches });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleSearchByRoom(e, callback) {
  try {
    const searchKey = e.parameter.room.toLowerCase().replace(/\s+/g, '');
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");
    const data = sheet.getDataRange().getValues();
    const matches = data.filter((row, index) => {
      if (index === 0) return false;
      const rowKey = String(row[1] || "").toLowerCase().replace(/\s+/g, '');
      return rowKey.includes(searchKey);
    }).map(row => ({
      reservation: row[0],
      room: row[1],
      name: row[2],
      checkIn: row[3],
      checkOut: row[4],
      guestCount: row[5],
      breakfastFlag: row[6],
      unpaid: row[9],
      memo: row[10]
    }));
    return jsonpResponse(callback, { success: true, matches });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleImportCsv(e, callback) {
  const csvData = e.parameter.csv;
  const command = e.parameter.command;

  if (command !== "clear" && !csvData) {
    return jsonpResponse(callback, { success: false, error: "Missing csv parameter" });
  }

  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");

    if (command === "clear") {
      if (sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
      }
      return jsonpResponse(callback, { success: true, cleared: true });
    }

    const rows = csvData.trim().split(';').map(line => {
      const [reservation, room, name, checkIn, checkOut, guestCount, breakfastFlag, searchName, hash, unpaid, memo] = line.split(',');
      return [reservation, room, name, checkIn, checkOut, guestCount, breakfastFlag, searchName, hash, unpaid, memo];
    });

    sheet.getRange(sheet.getLastRow() + 1, 1, rows.length, rows[0].length).setValues(rows);
    return jsonpResponse(callback, { success: true, inserted: rows.length });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleDefault(e, callback) {
  return jsonpResponse(callback, { success: false, error: "Invalid mode or missing parameters" });
}
function doPost(e) {
  const csvRaw = e.postData.contents;
  const callback = "handlePostResponse";

  if (!csvRaw) {
    return jsonpResponse(callback, { success: false, error: "No CSV data in POST" });
  }

  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");

    const rows = csvRaw.trim().split(';').map(line => {
      const [reservation, room, name, checkIn, checkOut, guestCount, breakfastFlag, searchName, hash, unpaid, memo] = line.split(',');
      return [reservation, room, name, checkIn, checkOut, guestCount, breakfastFlag, searchName, hash, unpaid, memo];
    });

    sheet.getRange(sheet.getLastRow() + 1, 1, rows.length, rows[0].length).setValues(rows);
    return jsonpResponse(callback, { success: true, inserted: rows.length });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}
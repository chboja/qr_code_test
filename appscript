const SHEET_ID = "1p1tktgK4vo9Yyc_dC1NB5WL-m2HNS_R6vYZAWWJSMXQ";

function jsonpResponse(callback, payload) {
  return ContentService
    .createTextOutput(`${callback}(${JSON.stringify(payload)})`)
    .setMimeType(ContentService.MimeType.JAVASCRIPT);
}

function doGet(e) {
  const mode = e.parameter.mode;
  const callback = e.parameter.callback || "handlePostResponse";

  switch (mode) {
    case "breakfastSubmit":
      return handleBreakfastSubmit(e, callback);
    case "verifyReservation":
      return handleVerifyReservation(e, callback);
    case "searchName":
      return handleSearchByName(e, callback);
    case "searchRoom":
      return handleSearchByRoom(e, callback);
    case "importCsv":
      return handleImportCsv(e, callback);
    case "fetchStats":
      return handleFetchStats(e, callback);
    case "guestNameList":
      return handleGuestNameList(e, callback);
    default:
      return handleDefault(e, callback);
  }
}

function handleBreakfastSubmit(e, callback) {
  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("breakfast_list");
    if (!sheet) throw new Error("breakfast_list not found");
    Logger.log("üü° Ï°∞Ïãù Îç∞Ïù¥ÌÑ∞ Í∏∞Î°ù ÏãúÎèÑ:", e.parameter);
    // Set number format of column 1 (timestamp) to plain text before writing values
    const lastRow = sheet.getLastRow() + 1;
    sheet.getRange(lastRow, 1).setNumberFormat('@');
    sheet.getRange(lastRow, 1, 1, 3).setValues([[e.parameter.timestamp, e.parameter.room, e.parameter.guests]]);
    Logger.log("üü¢ setValues ÏôÑÎ£å");
    return jsonpResponse(callback, { success: true });
  } catch (err) {
    Logger.log("‚ùå Ï°∞Ïãù Í∏∞Î°ù ÏóêÎü¨:", err);
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleVerifyReservation(e, callback) {
  try {
    const reservationToVerify = e.parameter.verifyReservation.trim().toLowerCase();
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");
    const data = sheet.getDataRange().getValues();
    // Collect logs for response
    const logs = [];
    logs.push("üîç ÌôïÏù∏Ìï† ÏòàÏïΩÎ≤àÌò∏ (from JS): '" + reservationToVerify + "'");
    for (let i = 1; i < data.length; i++) {
      const reservation = String(data[i][0]).trim().toLowerCase();
      logs.push("üîé row[" + i + "]: '" + reservation + "'");
    }
    const match = data.find((row, index) =>
      index !== 0 && String(row[0]).trim().toLowerCase() === reservationToVerify
    );
    const breakfastFlag = match ? String(match[6]) : null;
    return jsonpResponse(callback, {
      success: true,
      exists: !!match,
      reservationToVerify,
      matchedReservation: match ? String(match[0]) : null,
      breakfastFlag,
      logs
    });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleSearchByName(e, callback) {
  try {
    const searchKey = e.parameter.name.toLowerCase().replace(/\s+/g, '');
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");
    const data = sheet.getDataRange().getValues();
    const matches = data.filter((row, index) => {
      if (index === 0) return false;
      const rowKey = (row[7] || "").toLowerCase().replace(/\s+/g, '');
      return rowKey.includes(searchKey);
    }).map(row => ({
      reservation: row[0],
      room: row[1],
      name: row[2],
      checkIn: row[3],
      checkOut: row[4],
      guestCount: row[5],
      breakfastFlag: row[6],
      searchName: row[7],
      unpaid: row[8],
      memo: row[9]
    }));
    return jsonpResponse(callback, { success: true, matches });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleSearchByRoom(e, callback) {
  try {
    const searchKey = e.parameter.room.toLowerCase().replace(/\s+/g, '');
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");
    const data = sheet.getDataRange().getValues();
    const matches = data.filter((row, index) => {
      if (index === 0) return false;
      const rowKey = String(row[1] || "").toLowerCase().replace(/\s+/g, '');
      return rowKey.includes(searchKey);
    }).map(row => ({
      reservation: row[0],
      room: row[1],
      name: row[2],
      checkIn: row[3],
      checkOut: row[4],
      guestCount: row[5],
      breakfastFlag: row[6],
      searchName: row[7],
      unpaid: row[8],
      memo: row[9]
    }));
    return jsonpResponse(callback, { success: true, matches });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleImportCsv(e, callback) {
  const csvData = e.parameter.csv;
  const command = e.parameter.command;

  if (command !== "clear" && !csvData) {
    return jsonpResponse(callback, { success: false, error: "Missing csv parameter" });
  }

  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    if (!sheet) throw new Error("guest_list not found");

    if (command === "clear") {
      if (sheet.getLastRow() > 1) {
        sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
      }
      return jsonpResponse(callback, { success: true, cleared: true });
    }

    const rows = csvData.trim().split(';').map(line => {
      const [reservation, room, name, checkIn, checkOut, guestCount, breakfastFlag, searchName, hash, unpaid, memo] = line.split(',');
      return [reservation, room, name, checkIn, checkOut, guestCount, breakfastFlag, searchName, hash, unpaid, memo];
    });

    // Set number format to plain text for columns 1, 3, 4, 5, 8, 10 before inserting values
    const lastRow = sheet.getLastRow() + 1;
    const numRows = rows.length;
    const textColumns = [1, 3, 4, 5, 8, 10]; // 1-based column indices
    textColumns.forEach(function(col) {
      sheet.getRange(lastRow, col, numRows, 1).setNumberFormat('@');
    });

    sheet.getRange(lastRow, 1, numRows, rows[0].length).setValues(rows);
    return jsonpResponse(callback, { success: true, inserted: rows.length });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleDefault(e, callback) {
  return jsonpResponse(callback, { success: false, error: "Invalid mode or missing parameters" });
}

function handleFetchStats(e, callback) {
  try {
    const startDate = e.parameter.startDate;
    const endDate = e.parameter.endDate;
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("breakfast_list");
    if (!sheet) throw new Error("breakfast_list not found");

    const data = sheet.getDataRange().getValues();
    const results = [];

    for (let i = 1; i < data.length; i++) {
      const [timestamp, room, guests] = data[i];
      if (!timestamp || !room || !guests) continue;
      const date = timestamp.split(" ")[0];
      if (date >= startDate && date <= endDate) {
        results.push({ timestamp, date, room, guests: Number(guests) });
      }
    }

    const roomOnlySheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("room_only");
    const roomOnlyData = roomOnlySheet.getDataRange().getValues();
    const roomOnlyMap = {};

    for (let i = 1; i < roomOnlyData.length; i++) {
      const [rDate, rRoom] = roomOnlyData[i];
      if (!rDate || !rRoom) continue;
      if (rDate >= startDate && rDate <= endDate) {
        if (!roomOnlyMap[rDate]) roomOnlyMap[rDate] = [];
        roomOnlyMap[rDate].push(String(rRoom));
      }
    }

    return jsonpResponse(callback, {
      success: true,
      rows: results,
      roomOnly: roomOnlyMap
    });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}

function handleGuestNameList(e, callback) {
  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");
    const data = sheet.getDataRange().getValues();
    const list = data.slice(1).map(row => ({
      name: row[2] || "",
      searchName: (row[7] || "").toLowerCase()
    }));
    return jsonpResponse(callback, { success: true, list });
  } catch (err) {
    return jsonpResponse(callback, { success: false, error: err.message });
  }
}
// --- POST ÏóÖÎ°úÎìúÏö© doPost(e) Ìï®Ïàò ---
function doPost(e) {
  Logger.log("üì• Î∞õÏùÄ POST Îç∞Ïù¥ÌÑ∞: " + e.postData.contents);

  let body;
  try {
    body = JSON.parse(e.postData.contents || "{}");
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: "Invalid JSON: " + err.message
    })).setMimeType(ContentService.MimeType.JSON);
  }

  const rows = body.rows;
  const roomOnlyData = body.roomOnly;

  const result = {
    guestUpload: null,
    roomOnlyUpload: null,
  };

  try {
    // --- guest_list Ï≤òÎ¶¨ ---
    if (rows) {
      const guestSheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("guest_list");

      // ‚úÖ Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú (Ìó§ÎçîÎäî Ïú†ÏßÄ)
      if (guestSheet.getLastRow() > 1) {
        guestSheet.getRange(2, 1, guestSheet.getLastRow() - 1, guestSheet.getLastColumn()).clearContent();
      }

      const guestRows = rows.map(fields => {
        if (fields.length > 10) {
          fields[10] = fields[10].replace(/\\n/g, '\n');
        }
        return fields;
      });
      const guestLastRow = guestSheet.getLastRow() + 1;
      guestSheet.getRange(guestLastRow, 1, guestRows.length, guestRows[0].length)
        .setValues(guestRows)
        .setWrap(true);
      // --- Set number format to plain text for columns 1, 3, 4, 5, 8, 10 after setValues ---
      const textColumns = [1, 3, 4, 5, 8, 10]; // 1-based indices
      textColumns.forEach(function(col) {
        guestSheet.getRange(guestLastRow, col, guestRows.length, 1).setNumberFormat('@');
      });
      result.guestUpload = { success: true, inserted: guestRows.length };
    }

    // --- room_only Ï≤òÎ¶¨ ---
    if (roomOnlyData) {
      const roomSheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName("room_only");
      const today = new Date();
      today.setDate(today.getDate() + 1);
      const date = Utilities.formatDate(today, Session.getScriptTimeZone(), "yyyy-MM-dd");
      const newRoomRows = roomOnlyData.trim().split(',').map(room => [date, room]);

      const existingData = roomSheet.getDataRange().getValues();
      const header = existingData[0];
      const bodyRows = existingData.slice(1);

      const existingSet = new Set(bodyRows.map(row => `${row[0]}_${row[1]}`));
      const uniqueNewRows = newRoomRows.filter(([d, r]) => !existingSet.has(`${d}_${r}`));

      const finalData = [header, ...bodyRows, ...uniqueNewRows];
      roomSheet.clearContents();
      roomSheet.getRange(1, 1, finalData.length, finalData[0].length).setValues(finalData);
      // Set the first column (date) to plain text format
      roomSheet.getRange(2, 1, finalData.length - 1, 1).setNumberFormat('@');
      result.roomOnlyUpload = { success: true, inserted: uniqueNewRows.length };
    }

    return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: err.message,
      debug: {
        body,
        csvLength: csvData?.length || 0,
        roomOnlyLength: roomOnlyData?.length || 0
      }
    })).setMimeType(ContentService.MimeType.JSON);
  }
}